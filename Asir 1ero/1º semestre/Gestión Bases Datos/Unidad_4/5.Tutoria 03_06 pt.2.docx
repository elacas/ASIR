## Resumen desde el Minuto 6:2 - Tutor√≠a Gesti√≥n de Bases de Datos: Restricciones y Triggers

A partir del minuto 6:2, la tutor√≠a se centra en el **repaso pr√°ctico de restricciones** mediante un test interactivo y luego el **desarrollo completo de un sistema de reservas hoteleras** con implementaci√≥n de triggers y restricciones avanzadas.

### üß™ **Test de Repaso: Restricciones de Bases de Datos (6:2 - 25:22)**

#### **Metodolog√≠a del Repaso:**
> "Os he preparado unos test para a modo de recordatorio de la teor√≠a de ayer... hacemos un test as√≠ rapidillo de los siete ocho conceptos que vimos de restricciones"

#### **Preguntas Clave Resueltas:**

**1. Orden de Atributos en Tablas**
- **Pregunta:** ¬øDebo tener precauci√≥n con el orden de los atributos para cumplir restricciones inherentes?
- **Respuesta:** **FALSO** - El orden es transparente para el sistema

**2. Restricci√≥n PRIMARY KEY**
- **Pregunta:** ¬øCu√°l afirmaci√≥n es correcta sobre PRIMARY KEY?
- **Opciones:** Varias claves por tabla / Permite repetidos / No permite nulos ni repetidos / Solo una columna
- **Respuesta:** **C) No permite valores nulos ni repetidos**
- **Aclaraci√≥n:** Puede aplicarse a **m√∫ltiples columnas** (clave compuesta)

**3. Restricciones de Unicidad**
- **Pregunta:** ¬øQu√© restricci√≥n impide valores repetidos en columna(s) y que no sean nulos?
- **An√°lisis:** Tanto PRIMARY KEY como UNIQUE impiden repetici√≥n, pero solo PRIMARY KEY proh√≠be NULLs
- **Respuesta:** **PRIMARY KEY**

**4. Triggers y Eventos**
- **Pregunta:** Para actualizar valor medio de salarios, ¬øcu√°ndo activar el trigger?
- **Opciones:** BEFORE UPDATE, BEFORE DELETE, AFTER (cualquier evento), BEFORE INSERT
- **Respuesta:** **C) AFTER** - Despu√©s de modificaciones para recalcular

**5. Restricci√≥n NOT NULL**
- **Prop√≥sito:** Garantizar que columna siempre tenga valor
- **Aplicaci√≥n:** Autom√°tica en PRIMARY KEY, recomendada para datos esenciales

**6. Diferencia UNIQUE vs PRIMARY KEY**
- **UNIQUE:** Permite valores NULL m√∫ltiples
- **PRIMARY KEY:** No permite NULL, solo una por tabla

**7. AUTOINCREMENT**
- **Funci√≥n:** Generaci√≥n autom√°tica de identificadores √∫nicos
- **Uso t√≠pico:** Claves primarias de tipo entero

### üè® **Ejercicio Pr√°ctico: Sistema de Reservas Hoteleras (25:22 - Final)**

#### **Enunciado del Sistema:**
**Hotel con las siguientes caracter√≠sticas:**
- Gesti√≥n de **habitaciones** con tipos y precios
- Registro de **clientes** con identificadores propios
- Sistema de **reservas** con validaciones espec√≠ficas
- **Restricciones de negocio** complejas

#### **Identificaci√≥n de Entidades y Atributos:**

**Entidades detectadas:**
1. **HABITACIONES:** n√∫mero (√∫nico), tipo, precio_noche
2. **CLIENTES:** nombre, DNI, ID_cliente
3. **RESERVAS:** tabla intermedia para relaci√≥n N:M

**Restricciones de negocio identificadas:**
- Habitaci√≥n no puede reservarse dos veces para mismas fechas
- Precio de reserva debe ser positivo
- **Habitaciones tipo 'suite' deben tener precio m√≠nimo de 100‚Ç¨**
- Fecha de salida posterior a fecha de entrada

#### **Implementaci√≥n de la Base de Datos:**

**1. Creaci√≥n de la Base de Datos:**
```sql
DROP DATABASE IF EXISTS Triggers301;
CREATE DATABASE Triggers301;
USE Triggers301;
```

**2. Tabla CLIENTES:**
```sql
CREATE TABLE clientes (
    id_cliente INT PRIMARY KEY AUTO_INCREMENT,
    nombre VARCHAR(30) NOT NULL,
    dni VARCHAR(9) NOT NULL UNIQUE
);
```

**Caracter√≠sticas implementadas:**
- **ID_cliente:** Clave primaria autoincremental
- **Nombre y DNI:** Obligatorios (NOT NULL)
- **DNI:** √önico para evitar duplicados

**3. Tabla HABITACIONES:**
```sql
CREATE TABLE habitaciones (
    numero INT PRIMARY KEY AUTO_INCREMENT,
    tipo ENUM('individual', 'doble', 'suite') NOT NULL,
    precio_noche DECIMAL(10,2) NOT NULL
);
```

**Innovaciones t√©cnicas:**
- **ENUM:** Restricci√≥n de valores permitidos para tipo
- **DECIMAL(10,2):** Precisi√≥n monetaria
- **NOT NULL:** Campos obligatorios

### üîß **Implementaci√≥n de Restricci√≥n Compleja: Precio M√≠nimo Suite**

El profesor desarrolla **dos m√©todos alternativos** para implementar la regla: "Las habitaciones tipo 'suite' deben tener precio m√≠nimo de 100‚Ç¨"

#### **M√©todo 1: TRIGGER (Recomendado para L√≥gica Compleja)**

**Configuraci√≥n del delimitador:**
```sql
DELIMITER $$
```

**Trigger BEFORE INSERT:**
```sql
CREATE TRIGGER precio_suite 
BEFORE INSERT ON habitaciones 
FOR EACH ROW 
BEGIN 
    IF (NEW.tipo = 'suite' AND NEW.precio_noche < 100) THEN 
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = 'El precio de una Suite no puede ser inferior a 100‚Ç¨'; 
    END IF; 
END$$
```

**Trigger BEFORE UPDATE:**
```sql
CREATE TRIGGER precio_suite_update 
BEFORE UPDATE ON habitaciones 
FOR EACH ROW 
BEGIN 
    IF (NEW.tipo = 'suite' AND NEW.precio_noche < 100) THEN 
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = 'El precio de una Suite no puede ser inferior a 100‚Ç¨'; 
    END IF; 
END$$
```

**Restauraci√≥n del delimitador:**
```sql
DELIMITER ;
```

#### **M√©todo 2: Restricci√≥n CHECK (Alternativa Directa)**

**Implementaci√≥n con l√≥gica OR:**
```sql
ALTER TABLE habitaciones 
ADD CONSTRAINT habitacion_suite_check 
CHECK (tipo <> 'suite' OR precio_noche >= 100);
```

#### **An√°lisis L√≥gico de la Restricci√≥n CHECK:**

**Explicaci√≥n de la tabla de verdad:**
> "Para que la restricci√≥n se cumpla, la expresi√≥n debe ser TRUE"

| tipo = 'suite' | precio >= 100 | tipo <> 'suite' | Resultado OR | ¬øV√°lido? |
|----------------|----------------|-----------------|--------------|----------|
| FALSE          | FALSE          | TRUE            | TRUE         | ‚úÖ S√ç    |
| FALSE          | TRUE           | TRUE            | TRUE         | ‚úÖ S√ç    |
| TRUE           | FALSE          | FALSE           | FALSE        | ‚ùå NO    |
| TRUE           | TRUE           | FALSE           | TRUE         | ‚úÖ S√ç    |

**Casos pr√°cticos:**
- **Habitaci√≥n 'individual' con precio 50‚Ç¨:** ‚úÖ V√°lido (no es suite)
- **Habitaci√≥n 'suite' con precio 150‚Ç¨:** ‚úÖ V√°lido (es suite con precio >= 100)
- **Habitaci√≥n 'suite' con precio 80‚Ç¨:** ‚ùå **Error** (es suite con precio < 100)

### üîç **Conceptos de Validaci√≥n de Datos Ense√±ados:**

#### **1. Clasificaci√≥n de Restricciones:**
- **Inherentes:** Del sistema (no modificables)
- **Sem√°nticas:** Del usuario (opcionales, configurables)

#### **2. Jerarqu√≠a de Validaci√≥n:**
1. **Tipo de datos:** ENUM, INT, DECIMAL, VARCHAR
2. **Restricciones b√°sicas:** NOT NULL, UNIQUE, PRIMARY KEY
3. **Restricciones l√≥gicas:** CHECK con expresiones
4. **L√≥gica de negocio:** TRIGGERS para reglas complejas

#### **3. Cu√°ndo Usar Cada M√©todo:**

**TRIGGERS (Recomendado cuando):**
- L√≥gica condicional compleja
- M√∫ltiples condiciones interdependientes
- Necesidad de mensajes de error personalizados
- Validaciones que involucran m√∫ltiples tablas

**CHECK (Recomendado cuando):**
- Validaciones simples sobre columnas
- Expresiones l√≥gicas directas
- Mejor rendimiento para validaciones b√°sicas

### üíª **Herramientas y T√©cnicas Utilizadas:**

#### **Gesti√≥n de Delimitadores:**
```sql
DELIMITER $$  -- Cambio temporal para triggers
-- c√≥digo del trigger
DELIMITER ;   -- Restauraci√≥n
```

#### **Manejo de Errores Personalizados:**
```sql
SIGNAL SQLSTATE '45000' 
SET MESSAGE_TEXT = 'Mensaje personalizado';
```

#### **Sintaxis de Triggers:**
```sql
CREATE TRIGGER nombre_trigger
{BEFORE | AFTER} {INSERT | UPDATE | DELETE}
ON nombre_tabla
FOR EACH ROW
BEGIN
    -- l√≥gica del trigger
END
```

### üéØ **Objetivos de Aprendizaje Alcanzados:**

1. **Repaso consolidado** de restricciones b√°sicas
2. **Implementaci√≥n pr√°ctica** de sistema completo
3. **Comparaci√≥n de m√©todos** para validaciones complejas
4. **Uso avanzado de TRIGGERS** con l√≥gica condicional
5. **Comprensi√≥n de l√≥gica booleana** en restricciones CHECK
6. **Gesti√≥n de errores** personalizados en SQL

### üìö **Materiales Prometidos:**

**Compromiso del profesor:**
> "Os subir√© entre ma√±ana... ejercicios que contienen varios de estos trigger y restricciones... os pondr√© inserciones tanto las que son correctas como las que generan errores para que ve√°is qu√© errores generan y por qu√©"

### üîë **Conclusiones Clave:**

1. **Los triggers permiten l√≥gica compleja** que las restricciones CHECK no pueden manejar f√°cilmente
2. **Las restricciones CHECK son m√°s eficientes** para validaciones simples
3. **La combinaci√≥n de ambos m√©todos** proporciona validaci√≥n robusta
4. **Los mensajes de error personalizados** mejoran la experiencia del usuario
5. **La pr√°ctica incremental** facilita la comprensi√≥n de conceptos complejos

Esta parte de la tutor√≠a demuestra una **progresi√≥n pedag√≥gica excelente**, desde conceptos te√≥ricos hasta implementaci√≥n pr√°ctica completa, combinando repaso, aplicaci√≥n y comparaci√≥n de m√©todos alternativos para resolver el mismo problema de validaci√≥n de datos.