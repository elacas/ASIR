## Resumen Extendido: Tutor√≠a de Triggers y Restricciones - Sistema de Reservas de Hotel

Este video corresponde a una **tutor√≠a pr√°ctica avanzada** sobre **triggers y restricciones de bases de datos**, donde se desarrolla paso a paso un **sistema completo de reservas hoteleras** implementando validaciones complejas de datos.

### üéØ **Objetivos de la Tutor√≠a**
1. **Refrescar conceptos** de restricciones mediante test interactivo
2. **Desarrollar un caso pr√°ctico completo** de sistema hotelero
3. **Implementar triggers avanzados** para validaci√≥n de datos
4. **Comparar m√©todos alternativos** de validaci√≥n (CHECK vs TRIGGER)
5. **Aplicar conceptos te√≥ricos** en c√≥digo SQL funcional

### üìù **Fase 1: Repaso Te√≥rico Mediante Test Interactivo**

#### **Metodolog√≠a del Repaso:**
> "Os he preparado unos test para un test ligerito as√≠ para a modo de recordatorio de la teor√≠a de ayer... hacemos un test as√≠ rapidillo de los siete ocho conceptos que vimos de restricciones"

#### **Conceptos Clave Revisados:**

**1. Restricciones Inherentes vs Sem√°nticas**
- **Inherentes:** Programadas por el sistema, no modificables
- **Sem√°nticas:** Definidas por el usuario seg√∫n necesidades

**2. Primary Key - Caracter√≠sticas Fundamentales**
**Pregunta analizada:** ¬øCu√°l afirmaci√≥n es correcta sobre PRIMARY KEY?
- ‚úÖ **No permite valores nulos ni repetidos**
- ‚ùå Puede haber varias claves primarias por tabla
- ‚ùå Solo aplicable a una columna
- ‚úÖ **Puede aplicarse sobre m√∫ltiples columnas (clave compuesta)**

**Explicaci√≥n del profesor:**
> "La clave primaria puede estar formada por el atributo uno y el atributo tres por ejemplo... son dos columnas de la tabla y todo esto forma parte de la √∫nica clave primaria que hay"

**3. UNIQUE vs PRIMARY KEY**
**Diferencias fundamentales:**
- **UNIQUE:** Permite valores NULL m√∫ltiples
- **PRIMARY KEY:** No permite NULL, autom√°ticamente UNIQUE

> "Si yo defin√≠a una restricci√≥n unique no se van a repetir los valores donde haya valores pero si defino algunas filas con esa columna en null no hay problema... puede haber dos tres cinco nulls en esa columna"

**4. Triggers - Eventos y Temporizaci√≥n**
**Pregunta pr√°ctica:** ¬øCu√°ndo activar trigger para recalcular salario medio?
- **AFTER INSERT/UPDATE/DELETE:** Despu√©s de modificar datos
- **Justificaci√≥n:** Para actualizar c√°lculos derivados

### üè® **Fase 2: Desarrollo del Sistema de Reservas Hoteleras**

#### **Especificaciones del Sistema:**
```
ENTIDADES IDENTIFICADAS:
- CLIENTES: id_cliente, nombre, dni
- HABITACIONES: numero, tipo, precio_noche  
- RESERVAS: cliente_id, habitacion_id, fecha_entrada, fecha_salida
- TIPOS: individual, doble, suite

RESTRICCIONES DE NEGOCIO:
- Una habitaci√≥n no puede estar reservada dos veces para las mismas fechas
- El precio de la reserva debe ser positivo
- No se permiten reservas con fecha salida anterior a fecha de entrada
- Las habitaciones tipo suite deben tener precio m√≠nimo de 100‚Ç¨
- Un cliente puede realizar m√∫ltiples reservas
- Una habitaci√≥n puede ser reservada por varios clientes (fechas diferentes)
```

#### **Dise√±o Entidad-Relaci√≥n:**
```
CLIENTES (1) ----reservan----> (N) HABITACIONES
     ‚Üì                              ‚Üì
Relaci√≥n muchos a muchos se descompone en:
CLIENTES (1)--->(N) RESERVAS (N)<---(1) HABITACIONES
```

### üíª **Fase 3: Implementaci√≥n SQL Paso a Paso**

#### **3.1 Creaci√≥n de la Base de Datos**
```sql
-- Eliminar si existe y crear nueva
DROP DATABASE IF EXISTS triggers_301;
CREATE DATABASE triggers_301;
USE triggers_301;
```

#### **3.2 Tabla CLIENTES - Implementaci√≥n Completa**
```sql
CREATE TABLE clientes (
    id_cliente INT PRIMARY KEY AUTO_INCREMENT,
    nombre VARCHAR(30) NOT NULL,
    dni VARCHAR(9) NOT NULL UNIQUE
);
```

**Decisiones de dise√±o explicadas:**
- **AUTO_INCREMENT:** "Para no tener que estar preocup√°ndonos de su valor"
- **NOT NULL en nombre/DNI:** "El cliente debe registrarse con su nombre y su DNI"
- **UNIQUE en DNI:** "Sabemos que el DNI no se puede repetir... es una forma de reforzar su sistema ante errores"

#### **3.3 Tabla HABITACIONES - Restricciones Avanzadas**
```sql
CREATE TABLE habitaciones (
    numero INT PRIMARY KEY AUTO_INCREMENT,
    tipo ENUM('individual', 'doble', 'suite') NOT NULL,
    precio_noche DECIMAL(10,2) NOT NULL
);
```

**Innovaciones t√©cnicas:**
- **ENUM:** "Autom√°ticamente el sistema solamente va a admitir como valores v√°lidos... los que est√°n dentro de esta lista"
- **DECIMAL(10,2):** Para precios con decimales
- **NOT NULL obligatorio:** "Tenemos que ser capaces de identificar en esa reserva el tipo de habitaci√≥n porque eso nos va a fijar tambi√©n el precio"

### üîß **Fase 4: Implementaci√≥n de Triggers Avanzados**

#### **4.1 Trigger para Validaci√≥n de Precio Suite**

**Problema a resolver:**
> "Las habitaciones tipo suite deben tener un precio m√≠nimo de 100‚Ç¨"

**Implementaci√≥n del Trigger:**
```sql
DELIMITER $$

CREATE TRIGGER precio_suite 
BEFORE INSERT ON habitaciones 
FOR EACH ROW 
BEGIN 
    IF (NEW.tipo = 'suite' AND NEW.precio_noche < 100) THEN 
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = 'El precio de una Suite no puede ser inferior a 100 ‚Ç¨'; 
    END IF; 
END$$

DELIMITER ;
```

**Explicaci√≥n detallada del profesor:**
> "Quiero asegurarme de que la informaci√≥n que van a introducir sea correcta luego lo tengo que validar antes, de que se ejecute la escritura... IF new.tipo = 'suite' AND new.precio_noche < 100"

#### **4.2 Componentes del Trigger Explicados**

**A) Cambio de Delimitador:**
```sql
DELIMITER $$
-- ... c√≥digo del trigger ...
DELIMITER ;
```
**Prop√≥sito:** Permitir el uso de `;` dentro del c√≥digo del trigger

**B) Declaraci√≥n del Evento:**
- **BEFORE INSERT:** Se ejecuta antes de insertar
- **FOR EACH ROW:** Se ejecuta por cada fila afectada

**C) Manejo de Errores:**
- **SIGNAL SQLSTATE '45000':** C√≥digo de error personalizado
- **MESSAGE_TEXT:** Mensaje descriptivo del error

**D) Referencia a Datos:**
- **NEW.campo:** Valor que se va a insertar
- **OLD.campo:** Valor anterior (en UPDATE/DELETE)

### üîÄ **Fase 5: M√©todo Alternativo - Restricci√≥n CHECK**

#### **5.1 Implementaci√≥n con CHECK**
```sql
ALTER TABLE habitaciones 
ADD CONSTRAINT habitacion_suite_check 
CHECK (tipo <> 'suite' OR precio_noche >= 100);
```

#### **5.2 An√°lisis L√≥gico de la Restricci√≥n**

**Tabla de verdad explicada:**
```
tipo = 'suite'  |  precio >= 100  |  Resultado CHECK
----------------|------------------|------------------
    FALSE       |     FALSE        |     TRUE ‚úÖ
    FALSE       |     TRUE         |     TRUE ‚úÖ  
    TRUE        |     FALSE        |     FALSE ‚ùå
    TRUE        |     TRUE         |     TRUE ‚úÖ
```

**Explicaci√≥n del profesor:**
> "Si tipo no es suite (primera parte TRUE), no importa el precio ‚Üí se acepta
> Si tipo es suite, entonces precio debe ser ‚â• 100 para que se acepte"

### üìä **Fase 6: Comparaci√≥n de M√©todos de Validaci√≥n**

#### **6.1 Cu√°ndo Usar TRIGGER vs CHECK**

**TRIGGER - Ventajas:**
- **L√≥gica compleja:** M√∫ltiples condiciones, validaciones entre tablas
- **Mensajes personalizados:** Error descriptivo para el usuario
- **Flexibilidad:** Acceso a OLD y NEW, consultas a otras tablas

**CHECK - Ventajas:**
- **Simplicidad:** Validaciones directas en la definici√≥n de tabla
- **Performance:** Evaluaci√≥n m√°s r√°pida
- **Mantenimiento:** Menos c√≥digo que mantener

**Recomendaci√≥n del profesor:**
> "Lo que te resulte m√°s c√≥modo... habr√° ocasiones en las que te resulte m√°s c√≥modo tirar de trigger porque necesitas combinar dos condiciones"

#### **6.2 Casos de Uso Espec√≠ficos**

**Usar CHECK cuando:**
- Validaci√≥n simple de un atributo
- Condiciones l√≥gicas directas
- No se requieren mensajes personalizados

**Usar TRIGGER cuando:**
- Validaciones entre m√∫ltiples tablas
- L√≥gica de negocio compleja
...sigue en la parte 2